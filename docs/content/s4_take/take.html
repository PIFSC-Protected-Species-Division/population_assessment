<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Fishery take</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5d2e30ad26079c1dae90a1fd11eba2b9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../content/s4_take/take.html">Fishery take</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Methods Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/s1_imputation/imputation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Nest imputation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/s2_retrospective/retro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Retrospective trend</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/s3_future/future.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Future projections</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/s4_take/take.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Fishery take</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#incorporating-fishery-interactions-into-the-model" id="toc-incorporating-fishery-interactions-into-the-model" class="nav-link active" data-scroll-target="#incorporating-fishery-interactions-into-the-model">Incorporating fishery interactions into the model</a></li>
  <li><a href="#modeling-assumptions" id="toc-modeling-assumptions" class="nav-link" data-scroll-target="#modeling-assumptions">Modeling assumptions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Fishery take</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="incorporating-fishery-interactions-into-the-model" class="level3">
<h3 class="anchored" data-anchor-id="incorporating-fishery-interactions-into-the-model">Incorporating fishery interactions into the model</h3>
<p>In principle, the incorporation of fisheries interactions into the PVA projections is simple: during the calculation of the number of females in the next time step (<span class="math inline">\(\text{N}_{j+1}\)</span>), the number of females in the current time step (<span class="math inline">\(N_j\)</span>) is reduced by the incidental take in the current time step (<span class="math inline">\(F_j\)</span>) and multiplied by the finite population growth rate (<span class="math inline">\(\lambda\)</span>, = <span class="math inline">\(e^r\)</span>). <span class="math display">\[
\text{N}_{j+1} = (N_j - F_j) * e^r
\]</span> Therefore, the challenge comes from converting the incidental take of a given species (comprised of various lengths, ages, life stages, and sexes) to adult nester equivalents (ANE).</p>
<p><strong>1. Predicting anticipated take levels:</strong> The first goal is to generate the number and characteristics of the anticipated turtles that will be taken in each year. The number of turtles is referred to as the anticipated take level (ATL). Each year’s ATL was drawn from a Conway-Maxwell Poisson distribution (CMP), a two-parameter version of the Poisson distributions that includes a scale parameter <span class="math inline">\(\nu\)</span>. <span class="math inline">\(\mu_{s,j}\)</span> is the mean of the CMP distribution, and <span class="math inline">\(s\)</span> is one of three within-year segments which are summed to produce the total annual ATL (McCracken 2018<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>). <span class="math display">\[
\text{ATL}_{j} \; \text~ \sum^{3}_{s=1}{CMP(\mu_{s,j},\nu_{s,j})}
\]</span> Each individual in the annual ATL receives (1) a length and fishery mortality from a bivariate normal distribution, (2) a back-calculated age with years until maturity based on a von Bertalanffy growth model, (3) juvenile survival rate, (4) sex, and (5) a remigration interval.</p>
<p><strong>2. Lengths and fishery mortality.</strong> Based on historic incidental take, a bivariate normal distribution is used to generate lengths in logarithmic space and assign fishery mortality in logit space. <span class="math inline">\(\theta_{L,j}\)</span> is a linear function of the annual incidental take (<span class="math inline">\(F_j\)</span>) with intercept <span class="math inline">\(a_0\)</span> and slope <span class="math inline">\(a_1\)</span>, and <span class="math inline">\(\sum\)</span> is the variance-covariance matrix with variances <span class="math inline">\(\sigma_L^2\)</span> and <span class="math inline">\(\sigma_D^2\)</span> for the log lengths (log(<span class="math inline">\(L_k\)</span>)) and logit assigned fishery mortality (logit(<span class="math inline">\(D_k\)</span>)) to have correlated draws. The parameters of the multivariate normal distribution (<span class="math inline">\(a_0, a_1, \sigma_L, \sigma_D, \rho_{L,D}\)</span>) are solved for in a Bayesian framework using STAN via RStan with 7,500 simulations per chain (5,000 burn-in, 2,500 retained) with 4 chains. <span class="math display">\[
\left( \frac{log(L_k)}{logit(D_k)} \right) \;\text~MVN\left(\frac{\theta_{L,j}}{\theta_D},\;\scriptstyle\sum\;\right)
\]</span> <span class="math display">\[
\theta_{L,j} = a_0 + a_1F_j
\]</span></p>
<p><span class="math display">\[
\scriptstyle\sum = \left[\frac {\sigma_L^2}{}{\rho_{L,d}{}} \right]
\]</span> <span class="math display">\[
\Sigma = \begin{pmatrix}
\mathrm{\sigma_L^2} &amp; \mathrm{{\rho_{L,D}}{\sigma_{L}{\sigma_{D}} \\
\mathrm{{\rho_{L,D}}{\sigma_L}{\sigma_D}} &amp; \mathrm{\sigma_D^2}
\end{pmatrix}
\]</span></p>
<p><strong>3. Age and stage.</strong> From all lengths of historically taken turtles, a von Bertalanffy growth model (VBGM) is used to calculate the expected length at age across the range of lengths for each species. Using the VBGM for each species, the age at maturity (<span class="math inline">\(A_{mat}\)</span>) was assumed to correspond to a length of 97.5% of the maximum asymptotic maximum length (<span class="math inline">\(L_\infty\)</span>). Turtles with ages less than <span class="math inline">\(A_{mat}\)</span> or lengths less than 97.5% of (<span class="math inline">\(L_\infty\)</span>) are considered immature. Years until maturity are calculated for all turtles as <span class="math inline">\(Y_k = A_{mat} - {A_k}\)</span>, where <span class="math inline">\(A_k\)</span> is the age of the <span class="math inline">\(k\)</span>th individual.</p>
<p><strong>4. Remigration interval, juvenile survival, and sex.</strong> In deterministic runs, each individual in the anticipated take is assigned the mean remigration interval (<span class="math inline">\(RI\)</span>) and the mean juvenile survival (<span class="math inline">\(\phi\)</span>). In stochastic runs, each individual’s <span class="math inline">\(RI\)</span> is drawn from a distribution (CMP for leatherbacks, truncated normal for loggerheads) and their juvenile survival is drawn from a normal distribution. The sex of each animal is drawn from a Bernoulli distribution for the probability of being female.</p>
<p><strong>5. ANE calculation.</strong> Adults in the anticipated take are given ANEs of 1. Juvenile ANEs are calculated by projecting the juvenile survival over the number of years to maturity, and dividing by remigration interval. The stochastic nature of sex ratio and fishery mortality are applied to adjust the individual ANE. The probability of an individual taken by a fishery dying is used with a Bernoulli distribution to simulate whether an individual dies. Therefore, the ANE of the <span class="math inline">\(k\)</span>th individual is computed such that when the individual was a juvenile, female, and ended up dying, ANE was defined as the first equation below. However, when the individual was adult and either male or ends up alive, the ANE equals 0.</p>
<p><span class="math display">\[
ANE_k = \frac{\phi_J^{Y_k}}{RI}
\]</span> <span class="math display">\[
ANE_{realized,k} = \{{{\frac{\phi_J^{Y_k}}{RI}, Stage = J}\atop{1 \times Sex \times Discard, Stage = A}}
\]</span> <strong>5. Historical ANE imputation.</strong> To account for the historical impact on the population growth rates, ANE is also calculated historically. Each turtle’s length is used to generate a likely age, stage, and years to maturity. Juveniles’ years to maturity are rounded to the nearest year, and adults are assumed to be nesting in the year of their fishery interaction. <span class="math inline">\(Y_F\)</span> is the year incidental take occurred, <span class="math inline">\(Y_k\)</span> is the yeras to maturity, RI is the remigration interval (rounded to 3 years). The survival probability between each nesting year has to be accounted for so that the initial ANE is adjusted, where <span class="math inline">\(\phi_J\)</span> and <span class="math inline">\(\phi_A\)</span> are juvenile and adult survival rates, <span class="math inline">\(PF\)</span> is the proportion females, and <span class="math inline">\(D\)</span> is the assigned fishery mortality. <span class="math display">\[
Y_{nest,k} = \{{{Y_F+Y_k, y=1}\atop{Y_{nest,k}-1+RI, y&gt;1}}
\]</span> <span class="math display">\[
ANE_{k,j} = \{{{{\phi_J^{Nest_1}}\times{PF} \times D_k, y = 1}\atop{{\phi_A^{RI}, y&gt;1}}}
\]</span> <strong>6. Take calculation.</strong> After converting all individuals to ANEs, take (<span class="math inline">\(F_j\)</span>) from the earlier equation is substituted out for the summation of the individual ANEs in a given year. To account to process variance <span class="math inline">\(Q\)</span> from the trend analysis, the first equation below is modified to draw <span class="math inline">\(N_{j+1}\)</span> from a normal distribution. The modified population growth model presented below is used as the basis for the future projections described above to produce future scenarios with take incorporated. <span class="math display">\[
\text{N}_{j+1} = (N_j - ANE_{realized,j}) * e^r
\]</span> <span class="math display">\[
\text{N}_{j+1} = N((N_j - ANE_{realized,j}) * e^r, Q)
\]</span></p>
</section>
<section id="modeling-assumptions" class="level3">
<h3 class="anchored" data-anchor-id="modeling-assumptions">Modeling assumptions</h3>
<p>The anticipated take level (ATL) is constant through time and independent of fishery effort. This assumption was made by McCracken (2018) when generating the ATLs for the fishery.</p>
<p>The distribution of turtles’ sizes and post-interaction mortalities in the past is representative of what will be encountered in the future. We make this assumption when we use the fisheries observer data to inform characteristics of future turtles taken by the fishery, and do so because these are the best available data for the task.</p>
<p>The life history parameters are indicative of the populations of interest and are estimated accurately. Specifically, Amat(age at maturity) is 0.975 of Linf (asymptotic length; average length of mature females).</p>
<p>Turtles will nest immediately once they reach maturity.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>McCracken ML. 2018. Hawaii permitted shallow-set longline fishery estimated anticipated take level for Endangered Species Act listed species. In: NOAA Fisheries Pacific Islands Science Center, editor. Honolulu, HI USA<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>